// Script para probar la generaci√≥n de jerarqu√≠a versionada que guarda en Transcripts_aiusecase_id
require('dotenv').config();
const { MongoClient, ObjectId } = require('mongodb');
const HierarchyService = require('./src/services/hierarchy.service');
const ClasificadorService = require('./src/services/clasificador.service');
const SimilitudService = require('./src/services/similitud.service');

// Configuraci√≥n
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://decun:sixbell4455@cluster0.aixw3qc.mongodb.net/?retryWrites=true&w=majority';
const MONGODB_DB = process.env.MONGODB_DB || 'chatbot';
const TRANSCRIPT_AI_DB = 'Transcripts_aiusecase_id'; // Base de datos para las jerarqu√≠as
const TENANT_ID = 'davivienda';
const AIUSECASE_ID = 'clasificacion_conversaciones';
const BATCH_CUSTOM_NAME = process.env.BATCH_CUSTOM_NAME || 'Batch_Davivienda_2_1_270325';
const LIMITE_DOCUMENTOS = parseInt(process.env.LIMITE_DOCUMENTOS || '10', 10);
const DEBUG = process.env.DEBUG_MODE === 'true';
const ACTIVAR_AUTOMATICAMENTE = process.env.ACTIVAR_AUTO === 'true';

async function main() {
  console.log('üöÄ Iniciando procesamiento y jerarquizaci√≥n de conversaciones...');
  console.log(`üè¢ Tenant: ${TENANT_ID}`);
  console.log(`üè∑Ô∏è Batch: ${BATCH_CUSTOM_NAME}`);
  console.log(`üî¢ L√≠mite de documentos: ${LIMITE_DOCUMENTOS}`);
  
  let client;
  try {
    // Conectar a MongoDB
    console.log(`\nüîÑ Conectando a MongoDB: ${MONGODB_URI}`);
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    console.log('‚úÖ Conexi√≥n establecida');

    const db = client.db(MONGODB_DB);
    const dbTranscriptAI = client.db(TRANSCRIPT_AI_DB); // Conexi√≥n a la base de datos de jerarqu√≠as
    
    // Paso 1: Clasificar conversaciones
    const clasificaciones = await clasificarLote(db);
    
    if (clasificaciones.length === 0) {
      console.error('‚ùå No se pudieron obtener clasificaciones. Terminando proceso.');
      return;
    }
    
    // Paso 2: Generar jerarqu√≠a a partir de las clasificaciones
    const resultado = await generarJerarquia(db, dbTranscriptAI, clasificaciones);
    
    // Paso 3: Si est√° configurado, activar autom√°ticamente la versi√≥n
    if (ACTIVAR_AUTOMATICAMENTE && resultado && resultado.id) {
      await activarJerarquia(db, dbTranscriptAI, resultado.id);
    }
    
  } catch (error) {
    console.error('‚ùå Error general:', error);
  } finally {
    if (client) {
      console.log('\nüîÑ Cerrando conexi√≥n a MongoDB...');
      await client.close();
      console.log('‚úÖ Conexi√≥n cerrada');
    }
  }
}

async function clasificarLote(db) {
  console.log('\nüìã PASO 1: CLASIFICACI√ìN DE CONVERSACIONES');
  
  try {
    const coleccionOrigen = db.collection('Davivienda_transcripts');
    
    // Construir filtro
    const filtro = { "batchCustomName": BATCH_CUSTOM_NAME };
    
    // Consultar documentos
    console.log('üîç Consultando documentos...');
    const documentos = await coleccionOrigen.find(filtro)
      .limit(LIMITE_DOCUMENTOS)
      .toArray();

    console.log(`‚úÖ Se encontraron ${documentos.length} documentos`);
    
    if (documentos.length === 0) {
      console.error('‚ùå No se encontraron documentos con el batch especificado');
      return [];
    }
    
    // Inicializar servicios
    const clasificador = new ClasificadorService();
    
    // Array para almacenar todas las clasificaciones
    const todasLasClasificaciones = [];
    
    // Procesar documentos
    console.log('üîÑ Procesando documentos y clasificando conversaciones...');
    let contador = 0;
    let procesadas = 0;
    
    for (const documento of documentos) {
      try {
        contador++;
        console.log(`\nüìÑ Procesando documento ${contador}/${documentos.length}`);
        
        // Verificar si el documento contiene la propiedad "conversation"
        if (!documento.conversation || !Array.isArray(documento.conversation)) {
          console.warn('‚ö†Ô∏è El documento no contiene la propiedad "conversation" o no es un array');
          continue;
        }
        
        // Procesar cada conversaci√≥n en el documento
        for (const conversacionItem of documento.conversation) {
          try {
            procesadas++;
            console.log(`\nüó£Ô∏è Procesando conversaci√≥n ${procesadas} del documento ${contador}`);
            
            // Extraer texto de la conversaci√≥n
            const textoConversacion = extraerTextoConversacion(conversacionItem);
            
            if (!textoConversacion) {
              console.warn('‚ö†Ô∏è No se pudo extraer texto de conversaci√≥n v√°lido');
              continue;
            }
            
            console.log(`üÜî ID Conversaci√≥n: ${conversacionItem.conversationId}`);
            console.log(`üìù Longitud del texto: ${textoConversacion.length} caracteres`);
            
            // Clasificar la conversaci√≥n
            console.log('üîÑ Clasificando conversaci√≥n...');
            const tiempoInicio = Date.now();
            const clasificacion = await clasificador.clasificarConversacion(textoConversacion);
            
            console.log(`‚úÖ Clasificaci√≥n completada en ${Date.now() - tiempoInicio}ms`);
            console.log(`üìä Resultado: ${clasificacion.resultado.categoria} > ${clasificacion.resultado.subcategoria}`);
            
            // Agregar metadatos a la clasificaci√≥n
            const clasificacionConMetadata = {
              ...clasificacion.resultado,
              metadata: {
                idConversacion: conversacionItem.conversationId,
                clientId: conversacionItem.clientId || 0,
                batchCustomName: BATCH_CUSTOM_NAME
              }
            };
            
            // Agregar al array de clasificaciones
            todasLasClasificaciones.push(clasificacionConMetadata);
            
            // Guardar en MongoDB (opcional)
            await db.collection(`${TENANT_ID}_analysis`).updateOne(
              { 'metadata.idConversacion': conversacionItem.conversationId },
              {
                $set: {
                  tenant_id: TENANT_ID,
                  aiusecase_id: AIUSECASE_ID,
                  created_at: new Date(),
                  metadata: clasificacionConMetadata.metadata,
                  clasificacion: clasificacion.resultado,
                  estadisticas: clasificacion.estadisticas
                }
              },
              { upsert: true }
            );
            
          } catch (convError) {
            console.error(`‚ùå Error procesando conversaci√≥n:`, convError.message);
          }
        }
      } catch (error) {
        console.error(`‚ùå Error procesando documento:`, error.message);
      }
    }
    
    console.log(`\nüìä Resumen de clasificaci√≥n:`);
    console.log(`   - Documentos procesados: ${contador}`);
    console.log(`   - Conversaciones procesadas: ${procesadas}`);
    console.log(`   - Clasificaciones generadas: ${todasLasClasificaciones.length}`);
    
    // Guardar todas las clasificaciones en un archivo para depuraci√≥n
    const fs = require('fs');
    const nombreArchivoClasificaciones = `clasificaciones_${BATCH_CUSTOM_NAME}_${new Date().toISOString().replace(/:/g, '-')}.json`;
    fs.writeFileSync(nombreArchivoClasificaciones, JSON.stringify(todasLasClasificaciones, null, 2));
    console.log(`\nüíæ Clasificaciones guardadas en: ${nombreArchivoClasificaciones}`);
    
    return todasLasClasificaciones;
    
  } catch (error) {
    console.error('‚ùå Error en clasificaci√≥n de lote:', error);
    return [];
  }
}

async function generarJerarquia(db, dbTranscriptAI, clasificaciones) {
  console.log('\nüìã PASO 2: GENERACI√ìN DE JERARQU√çA VERSIONADA');
  
  try {
    if (clasificaciones.length === 0) {
      console.error('‚ùå No hay clasificaciones para generar jerarqu√≠a');
      return;
    }
    
    console.log(`üî¢ N√∫mero de clasificaciones para jerarquizar: ${clasificaciones.length}`);
    
    // Extraer solo las tripletas (categor√≠a, subcategor√≠a, detalle)
    const tripletas = clasificaciones.map(c => ({
      categoria: c.categoria,
      subcategoria: c.subcategoria,
      detalle: c.detalle || ''
    }));
    
    console.log('üìä Ejemplo de clasificaciones:');
    tripletas.slice(0, 3).forEach((t, i) => {
      console.log(`   ${i+1}. ${t.categoria} > ${t.subcategoria} > ${t.detalle}`);
    });
    
    // Inicializar servicio de similitud
    const similitudService = new SimilitudService();
    
    // Generar jerarqu√≠a
    console.log('\nüîÑ Generando jerarqu√≠a a partir de las clasificaciones...');
    const tiempoInicio = Date.now();
    const jerarquia = await similitudService.agruparClasificaciones(tripletas);
    console.log(`‚úÖ Jerarqu√≠a generada en ${Date.now() - tiempoInicio}ms`);
    
    // Colecciones en ambas bases de datos
    const coleccionOriginal = db.collection(`${TENANT_ID}_hierarchies`);
    const coleccionHierarchies = dbTranscriptAI.collection('davivienda_hierarchies');
    const coleccionProposals = dbTranscriptAI.collection('davivienda_hierarchiesproposals');
    
    // Obtener la √∫ltima versi√≥n
    const ultimaJerarquia = await coleccionOriginal.findOne(
      { tenant_id: TENANT_ID, aiusecase_id: AIUSECASE_ID },
      { sort: { version: -1 } }
    );
    
    const nuevaVersion = ultimaJerarquia ? ultimaJerarquia.version + 1 : 1;
    
    // Verificar si hay una versi√≥n activa
    const versionActiva = await coleccionOriginal.findOne({
      tenant_id: TENANT_ID,
      aiusecase_id: AIUSECASE_ID,
      'metadata.active': true
    });
    
    // Preparar documento para guardar
    const documento = {
      created_at: new Date(),
      tenant_id: TENANT_ID,
      aiusecase_id: AIUSECASE_ID,
      version: nuevaVersion,
      hierarchy: jerarquia,
      metadata: {
        total_classifications: clasificaciones.length,
        filters: {
          fecha: null,
          batch: BATCH_CUSTOM_NAME
        },
        status: "proposed"
      }
    };
    
    // Si no hay versi√≥n activa, activar esta
    if (!versionActiva) {
      documento.metadata.active = true;
      documento.metadata.activated_at = new Date();
      documento.metadata.previous_version = null;
    }
    
    // Guardar en MongoDB (base de datos original)
    console.log('üíæ Guardando jerarqu√≠a versionada en MongoDB (base de datos original)...');
    const resultado = await coleccionOriginal.insertOne(documento);
    
    console.log(`‚úÖ Jerarqu√≠a guardada con ID: ${resultado.insertedId} en ${TENANT_ID}_hierarchies`);
    
    // Guardar tambi√©n en Transcripts_aiusecase_id
    console.log('üíæ Guardando jerarqu√≠a en Transcripts_aiusecase_id...');
    
    // 1. Guardar en davivienda_hierarchiesproposals (siempre)
    console.log('üíæ Guardando como propuesta en davivienda_hierarchiesproposals');
    const documentoProposal = {
      ...documento,
      original_id: resultado.insertedId.toString()
    };
    await coleccionProposals.insertOne(documentoProposal);
    
    // 2. Guardar en davivienda_hierarchies si es activa
    if (documento.metadata.active) {
      console.log('üü¢ Guardando como jerarqu√≠a activa en davivienda_hierarchies');
      const documentoHierarchy = {
        ...documento,
        original_id: resultado.insertedId.toString()
      };
      await coleccionHierarchies.insertOne(documentoHierarchy);
    }
    
    console.log(`üî¢ Versi√≥n: ${nuevaVersion}`);
    console.log(`üü¢ Estado: ${documento.metadata.active ? 'Activa' : 'Propuesta'}`);
    
    // Guardar en archivo para depuraci√≥n
    const fs = require('fs');
    const nombreArchivoJerarquia = `jerarquia_${BATCH_CUSTOM_NAME}_v${nuevaVersion}_${new Date().toISOString().replace(/:/g, '-')}.json`;
    fs.writeFileSync(nombreArchivoJerarquia, JSON.stringify(jerarquia, null, 2));
    console.log(`üíæ Jerarqu√≠a tambi√©n guardada en: ${nombreArchivoJerarquia}`);
    
    return {
      id: resultado.insertedId,
      version: nuevaVersion,
      isActive: documento.metadata.active || false
    };
    
  } catch (error) {
    console.error('‚ùå Error generando jerarqu√≠a:', error);
  }
}

async function activarJerarquia(db, dbTranscriptAI, jerarquiaId) {
  console.log('\nüìã PASO 3: ACTIVACI√ìN DE JERARQU√çA');
  
  try {
    console.log(`üîÑ Activando jerarqu√≠a con ID: ${jerarquiaId}...`);
    
    const coleccionOriginal = db.collection(`${TENANT_ID}_hierarchies`);
    const coleccionHierarchies = dbTranscriptAI.collection('davivienda_hierarchies');
    const coleccionProposals = dbTranscriptAI.collection('davivienda_hierarchiesproposals');
    
    // Encontrar la versi√≥n a activar
    const versionToActivate = await coleccionOriginal.findOne({
      _id: new ObjectId(jerarquiaId)
    });
    
    if (!versionToActivate) {
      throw new Error(`No se encontr√≥ la jerarqu√≠a con ID ${jerarquiaId}`);
    }
    
    // Obtener la versi√≥n activa actual
    const activeVersion = await coleccionOriginal.findOne({
      tenant_id: TENANT_ID,
      aiusecase_id: AIUSECASE_ID,
      'metadata.active': true
    });
    
    const previousVersionId = activeVersion ? activeVersion._id : null;
    
    // Desactivar la versi√≥n activa actual
    if (activeVersion) {
      // Desactivar en la colecci√≥n original
      await coleccionOriginal.updateOne(
        { _id: activeVersion._id },
        { 
          $set: { 
            'metadata.active': false,
            'metadata.status': 'inactive'
          } 
        }
      );
      
      // Desactivar en davivienda_hierarchies y davivienda_hierarchiesproposals
      await coleccionHierarchies.updateMany(
        { original_id: activeVersion._id.toString() },
        { 
          $set: { 
            'metadata.active': false,
            'metadata.status': 'inactive'
          } 
        }
      );
      
      await coleccionProposals.updateMany(
        { original_id: activeVersion._id.toString() },
        { 
          $set: { 
            'metadata.active': false,
            'metadata.status': 'inactive'
          } 
        }
      );
    }
    
    // Activar la nueva versi√≥n en la colecci√≥n original
    await coleccionOriginal.updateOne(
      { _id: new ObjectId(jerarquiaId) },
      { 
        $set: { 
          'metadata.active': true,
          'metadata.activated_at': new Date(),
          'metadata.previous_version': previousVersionId ? previousVersionId.toString() : null,
          'metadata.status': 'active'
        } 
      }
    );
    
    // Activar en davivienda_hierarchiesproposals
    await coleccionProposals.updateMany(
      { original_id: jerarquiaId.toString() },
      { 
        $set: { 
          'metadata.active': true,
          'metadata.activated_at': new Date(),
          'metadata.previous_version': previousVersionId ? previousVersionId.toString() : null,
          'metadata.status': 'active'
        } 
      }
    );
    
    // Buscar la propuesta en proposals
    const propuestaEnProposals = await coleccionProposals.findOne({
      original_id: jerarquiaId.toString()
    });
    
    if (propuestaEnProposals) {
      // Eliminar el _id para que MongoDB genere uno nuevo
      const documentoHierarchy = { ...propuestaEnProposals };
      delete documentoHierarchy._id;
      
      // Actualizar metadatos
      documentoHierarchy.metadata.active = true;
      documentoHierarchy.metadata.activated_at = new Date();
      documentoHierarchy.metadata.previous_version = previousVersionId ? previousVersionId.toString() : null;
      documentoHierarchy.metadata.status = 'active';
      
      // Revisar si ya existe en hierarchies
      const existeEnHierarchies = await coleccionHierarchies.findOne({
        original_id: jerarquiaId.toString()
      });
      
      if (existeEnHierarchies) {
        // Actualizar si ya existe
        await coleccionHierarchies.updateOne(
          { original_id: jerarquiaId.toString() },
          { $set: documentoHierarchy }
        );
      } else {
        // Insertar si no existe
        await coleccionHierarchies.insertOne(documentoHierarchy);
      }
    } else {
      console.warn(`‚ö†Ô∏è No se encontr√≥ la propuesta con ID ${jerarquiaId} en davivienda_hierarchiesproposals`);
    }
    
    console.log(`‚úÖ Jerarqu√≠a versi√≥n ${versionToActivate.version} activada correctamente`);
    
    return {
      success: true,
      message: `Jerarqu√≠a versi√≥n ${versionToActivate.version} activada correctamente`,
      version: versionToActivate.version
    };
  } catch (error) {
    console.error('‚ùå Error activando jerarqu√≠a:', error);
  }
}

function extraerTextoConversacion(conversacionItem) {
  try {
    // Verificar si tiene los mensajes de la conversaci√≥n
    if (!conversacionItem.conversation || !Array.isArray(conversacionItem.conversation)) {
      return null;
    }
    
    // Filtrar mensajes que no son metadata
    const mensajes = conversacionItem.conversation.filter(msg => 
      msg.role !== 'metadata' && msg.content && typeof msg.content === 'string'
    );
    
    // Construir el texto de la conversaci√≥n
    const textoConversacion = mensajes.map(msg => {
      const rol = msg.role === 'agent' ? 'Agente' : 'Cliente';
      return `${rol}: ${msg.content}`;
    }).join('\n');
    
    return textoConversacion;
  } catch (error) {
    console.error('Error extrayendo texto de conversaci√≥n:', error);
    return null;
  }
}

// Ejecutar el script
main().catch(error => {
  console.error('Error fatal:', error);
  process.exit(1);
});